name: CI Failure Feedback

on:
  workflow_run:
    workflows: ["CI"]
    types:
      - completed

permissions:
  contents: read
  pull-requests: write
  actions: read

jobs:
  feedback:
    name: Provide Feedback on CI Failure
    runs-on: ubuntu-latest
    # Only run if CI failed and it was triggered by a pull request
    if: >
      github.event.workflow_run.conclusion == 'failure' &&
      github.event.workflow_run.event == 'pull_request'
    steps:
      - uses: actions/checkout@v4

      - name: Get PR Information
        id: pr-info
        uses: actions/github-script@v7
        with:
          script: |
            const runId = context.payload.workflow_run.id;
            const headSha = context.payload.workflow_run.head_sha;
            const headBranch = context.payload.workflow_run.head_branch;
            
            // Get PR associated with this workflow run
            const prs = context.payload.workflow_run.pull_requests;
            if (!prs || prs.length === 0) {
              // Try to find PR by head branch
              const { data: pulls } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${headBranch}`,
                state: 'open'
              });
              
              if (pulls.length === 0) {
                console.log('No PR found for this workflow run');
                core.setOutput('has_pr', 'false');
                return;
              }
              
              core.setOutput('pr_number', pulls[0].number);
            } else {
              core.setOutput('pr_number', prs[0].number);
            }
            
            core.setOutput('has_pr', 'true');
            core.setOutput('run_id', runId);
            core.setOutput('head_sha', headSha);

      - name: Collect Failures and Post Comment
        if: steps.pr-info.outputs.has_pr == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = parseInt('${{ steps.pr-info.outputs.pr_number }}', 10);
            const runId = parseInt('${{ steps.pr-info.outputs.run_id }}', 10);
            const headSha = '${{ steps.pr-info.outputs.head_sha }}';
            
            // Get all jobs for the workflow run
            const { data: jobsData } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId
            });
            
            const failedJobs = jobsData.jobs.filter(job => job.conclusion === 'failure');
            
            if (failedJobs.length === 0) {
              console.log('No failed jobs found');
              return;
            }
            
            // Collect job summaries with logs
            const summaries = [];
            for (const job of failedJobs) {
              try {
                // Get job logs - returns binary data, need to convert to string
                const response = await github.rest.actions.downloadJobLogsForWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  job_id: job.id
                });
                
                // Convert to string - response.data is the log content
                const logs = typeof response.data === 'string' ? response.data : response.data.toString();
                
                // Extract relevant error lines
                const logLines = logs.split('\n');
                const seenLines = new Set();
                const errorLines = [];
                const relevantPatterns = [/error/i, /failed/i, /failure/i, /exception/i, /panic/i];
                
                // Get lines around errors
                for (let i = 0; i < logLines.length; i++) {
                  const line = logLines[i];
                  if (relevantPatterns.some(pattern => pattern.test(line))) {
                    // Add context: 2 lines before and 2 lines after
                    const start = Math.max(0, i - 2);
                    const end = Math.min(logLines.length, i + 3);
                    for (let j = start; j < end; j++) {
                      if (!seenLines.has(logLines[j])) {
                        seenLines.add(logLines[j]);
                        errorLines.push(logLines[j]);
                      }
                    }
                  }
                }
                
                // If no specific errors found, get last 30 lines
                let logSummary;
                if (errorLines.length === 0) {
                  logSummary = logLines.slice(-30).join('\n');
                } else {
                  // Limit to 50 lines to avoid huge comments
                  logSummary = errorLines.slice(0, 50).join('\n');
                }
                
                summaries.push({
                  name: job.name,
                  url: job.html_url,
                  logs: logSummary
                });
              } catch (error) {
                console.log(`Failed to get logs for job ${job.name}: ${error.message}`);
                summaries.push({
                  name: job.name,
                  url: job.html_url,
                  logs: 'Unable to retrieve logs'
                });
              }
            }
            
            // Check existing comments to count failures
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });
            
            // Find CI feedback comments from this workflow
            const feedbackComments = comments.filter(comment => 
              comment.body && 
              comment.body.includes('<!-- CI-FEEDBACK-BOT -->') &&
              comment.user && comment.user.type === 'Bot'
            );
            
            // Count failures per job from previous comments
            const jobFailureCounts = {};
            for (const comment of feedbackComments) {
              // Parse job names from previous comments
              const jobMatches = comment.body.match(/### ‚ùå Job: `([^`]+)`/g);
              if (jobMatches) {
                for (const match of jobMatches) {
                  const innerMatch = match.match(/### ‚ùå Job: `([^`]+)`/);
                  if (innerMatch && innerMatch[1]) {
                    const jobName = innerMatch[1];
                    jobFailureCounts[jobName] = (jobFailureCounts[jobName] || 0) + 1;
                  }
                }
              }
            }
            
            // Filter jobs that have failed less than 3 times
            const jobsToReport = summaries.filter(summary => {
              const count = jobFailureCounts[summary.name] || 0;
              if (count >= 3) {
                console.log(`Skipping job "${summary.name}" - already failed ${count} times`);
                return false;
              }
              return true;
            });
            
            if (jobsToReport.length === 0) {
              console.log('All failed jobs have exceeded the 3 failure limit. Not posting comment.');
              return;
            }
            
            // Check if any jobs are being skipped due to failure limit
            const skippedJobs = summaries.filter(summary => {
              const count = jobFailureCounts[summary.name] || 0;
              return count >= 3;
            });
            
            // Build comment body
            let commentBody = `<!-- CI-FEEDBACK-BOT -->\n## üö® CI Failure Report\n\n`;
            commentBody += `**Workflow Run:** [#${runId}](${context.payload.workflow_run.html_url})\n`;
            commentBody += `**Commit:** \`${headSha.substring(0, 7)}\`\n\n`;
            commentBody += `The following CI jobs have failed:\n\n`;
            
            for (const summary of jobsToReport) {
              const failureCount = (jobFailureCounts[summary.name] || 0) + 1;
              commentBody += `### ‚ùå Job: \`${summary.name}\`\n\n`;
              commentBody += `**Failure #${failureCount}/3** | [View Full Logs](${summary.url})\n\n`;
              commentBody += `<details>\n<summary>Error Summary</summary>\n\n`;
              commentBody += `\`\`\`\n${summary.logs}\n\`\`\`\n\n`;
              commentBody += `</details>\n\n`;
            }
            
            if (skippedJobs.length > 0) {
              commentBody += `---\n\n`;
              commentBody += `‚ö†Ô∏è **Note:** The following jobs have failed 3+ times and will no longer trigger auto-feedback:\n`;
              commentBody += skippedJobs.map(j => `- \`${j.name}\``).join('\n') + '\n\n';
            }
            
            commentBody += `---\n\n`;
            commentBody += `@copilot Please analyze these CI failures and suggest fixes based on the error logs above.\n`;
            
            // Post the comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: commentBody
            });
            
            console.log(`Posted CI feedback comment on PR #${prNumber}`);
